// No TypeScript code directly in this block, it's for conceptual explanation.
// Firestore collection and document structure will be described below.
// Component logic will be described conceptually and then shown in component updates.
```text
## Firestore Collection Design

Based on the fields in your `personal-information-form.html` and the authentication flow, here's a suggested Firestore structure:

**1. `users` Collection**

* **Document ID:** `uid` (This will be the User ID provided by Firebase Authentication upon user creation/login).
* **Fields within each user document:**
    * `uid`: (String) The Firebase Auth UID. Store it again for easier querying if needed.
    * `email`: (String) The user's primary email address (often from Firebase Auth). This should be kept in sync.
    * `displayName`: (String) The user's full name. Can be pre-filled from a social provider or entered by the user.
    * `photoURL`: (String, nullable) URL to the user's profile picture. Can be from a social provider or uploaded later.
    * `dateOfBirth`: (Timestamp or String in ISO 8601 format, e.g., "YYYY-MM-DD") User's date of birth.
    * `gender`: (String, nullable) e.g., 'male', 'female'.
    * `authProviders`: (Array of Strings) Stores the provider IDs the user has authenticated with (e.g., `['google.com', 'password']`, `['facebook.com']`). This helps understand how the user account was created or linked.
    * `isRegistrationComplete`: (Boolean) **Crucial flag.** Set to `false` upon initial Firebase Auth account creation. Set to `true` only after the user successfully submits the complete "Personal Information" form.
    * `createdAt`: (Timestamp) When the user document (or initial auth record) was created.
    * `updatedAt`: (Timestamp) When the user document was last updated.

**2. `users/{userId}/addresses` Subcollection**

* This subcollection will store multiple addresses for each user.
* **Document ID:** Auto-generated by Firestore (e.g., `addressId1`, `addressId2`).
* **Fields within each address document:**
    * `label`: (String) A user-defined label for the address (e.g., "Home", "Work", "Mom's House"). The original HTML had "789 Maple Drive" which could be a label or part of the address.
    * `fullAddress`: (String) The complete street address, city, state, postal code, country.
    * `type`: (String) e.g., "Primary", "Secondary", or the user-defined label if preferred.
    * `iconKey`: (String) An identifier for the icon associated with the address (e.g., 'home', 'work', 'location_on' to map to Material Icons).
    * `isPrimary`: (Boolean) Indicates if this is the user's primary address. (Ensure only one address can be primary).
    * `createdAt`: (Timestamp)
    * `updatedAt`: (Timestamp)

---

## Application Flow and Logic for Profile Completion

Here's how the Firestore `isRegistrationComplete` flag and conditional password fields will work:

**A. User Sign-Up / Sign-In Flow:**

1.  **`SignInPageComponent`:**
    * **Social Login (Google/Facebook):**
        * User clicks "Continue with Google" or "Continue with Facebook".
        * `AuthService.loginWithGoogle()` or `AuthService.loginWithFacebook()` is called.
        * Upon successful Firebase Authentication:
            * Check if a user document already exists in Firestore for this `uid`.
            * If **not existing OR if `isRegistrationComplete` is `false`**:
                * Create/update the Firestore user document:
                    * Set `uid`, `email`, `displayName`, `photoURL` from the auth provider.
                    * Set `authProviders` (e.g., `['google.com']`).
                    * Set `isRegistrationComplete` to `false`.
                    * Set `createdAt`.
                * Navigate the user to the "Add Personal Information" page (e.g., `/profile/personal-info`). Pass state if necessary (e.g., `{ fromSocial: true }`).
            * If **existing AND `isRegistrationComplete` is `true`**:
                * Update `authProviders` if a new provider was used to sign in.
                * Navigate to the main app area (e.g., `/dashboard`).
    * **"Continue with Email":**
        * User clicks this.
        * Navigate to your dedicated email/password sign-up page (e.g., `SignUpEmailPageComponent` which has fields for email, password, confirm password, and optionally display name).
        * **`SignUpEmailPageComponent`:**
            * User submits the form.
            * `AuthService.signUpWithEmailPassword(email, password, displayName)` is called.
            * Upon successful Firebase Authentication account creation:
                * Create the Firestore user document:
                    * Set `uid`, `email`, `displayName` (if provided).
                    * Set `authProviders` to `['password']`.
                    * Set `isRegistrationComplete` to `false`.
                    * Set `createdAt`.
                * Navigate the user to the "Add Personal Information" page (`/profile/personal-info`) to complete their profile (DOB, Gender, Addresses). Pass state: `{ source: 'emailSignUp', email: userEmail }`.

2.  **`LoginPageComponent`:**
    * User logs in with existing email/password or social provider.
    * Upon successful Firebase Authentication:
        * Fetch the user document from Firestore using the `uid`.
        * If **document doesn't exist OR `isRegistrationComplete` is `false`**:
            * (If document doesn't exist, create it with basic info and `isRegistrationComplete: false`).
            * Navigate to "Add Personal Information" page (`/profile/personal-info`).
        * If **`isRegistrationComplete` is `true`**:
            * Navigate to the main app area (e.g., `/dashboard`).

**B. `PersonalInfoPageComponent` Logic:**

This page is for completing the profile after initial Firebase Auth account creation or for editing existing information.

* **Path:** `src/app/features/user-profile/personal-info-page/personal-info-page.component.ts`
* **Key Logic:**
    * **`ngOnInit()`:**
        * Get the current Firebase authenticated user (`authService.getCurrentUser()`). If no user, redirect to login.
        * Fetch the corresponding user document from Firestore.
        * Pre-fill form fields (Name, Email, DOB, Gender) with data from Firestore or the Auth provider.
        * **Gender Options:** The options for the gender selection field should be limited to 'male' and 'female'.
            ```typescript
            // Example genderOptions in PersonalInfoPageComponent.ts
            genderOptions: SelectOption[] = [ // Assuming SelectOption is { value: string, viewValue: string }
              { value: 'male', viewValue: 'Male' },
              { value: 'female', viewValue: 'Female' },
            ];
            ```
        * **Conditional Password Fields:**
            * The "Password" and "Confirm Password" `FormControl`s from your original HTML are part of the form definition.
            * Determine if these fields should be active (enabled and validated):
                * Check route state passed during navigation (e.g., `history.state.source === 'emailSignUpInitialSetup'` if you want to force password setup/confirmation on this page for first-time email signups *if the password wasn't set on a previous dedicated screen*).
                * **More commonly, these fields on a "Personal Info" page are for *changing* an existing password, not initial setup after an email/password account is already created.** If the user just signed up with email/password on `SignUpEmailPageComponent`, they've already set their password.
                * **For your requirement "activate the Password and Confirm Password fields if the user signed in using the Email option on the Sign-In page":**
                    * This implies if they came from an email flow and `isRegistrationComplete` is `false`, they might need to set/confirm a password *here*. This is unusual if `SignUpEmailPageComponent` already handled password creation.
                    * **Alternative Interpretation & Simpler Flow:**
                        * If the "Email option" on `SignInPageComponent` leads to `SignUpEmailPageComponent` (where password IS set), then `PersonalInfoPageComponent` does NOT need active password fields for initial setup. They would only be for a "Change Password" feature.
                        * If you want to simplify and have "Continue with Email" lead *directly* to `PersonalInfoPageComponent` to set everything including the password for the first time, then:
                            * `PersonalInfoPageComponent` would need to know it's in "initial email setup mode".
                            * The `onSave()` method would call `authService.signUpWithEmailPassword()` instead of just updating profile data. This makes `PersonalInfoPageComponent` a combined sign-up and profile completion page for email users.
                            * For social sign-ups, these password fields would be disabled or hidden.

    * **Let's assume a flow where `PersonalInfoPageComponent` *can* handle initial password setup for email users if they land here directly after only providing an email, or if linking a password to a social account.**
        ```typescript
        // In PersonalInfoPageComponent.ts
        // ...
        isInitialEmailPasswordSetup = signal(false); // Set based on route state or other logic

        // Update genderOptions if defined in the component
        genderOptions: Array<{ value: string; viewValue: string }> = [
          { value: 'male', viewValue: 'Male' },
          { value: 'female', viewValue: 'Female' },
        ];


        ngOnInit(): void {
          // ...
          const navigationState = history.state;
          if (navigationState.source === 'newEmailUserNeedsPassword') {
            this.isInitialEmailPasswordSetup.set(true);
            // Pre-fill email if passed
            if (navigationState.email) {
              this.personalInfoForm.patchValue({ email: navigationState.email });
              this.personalInfoForm.get('email')?.disable(); // Don't let them change email if pre-filled this way
            }
          }

          this.personalInfoForm = this.fb.group({
            name: new FormControl('', Validators.required),
            dateOfBirth: new FormControl('', Validators.required),
            email: new FormControl({ value: '', disabled: this.isInitialEmailPasswordSetup() }, [Validators.required, Validators.email]),
            password: new FormControl('', this.isInitialEmailPasswordSetup() ? [Validators.required, Validators.minLength(8)] : []),
            repeatPassword: new FormControl('', this.isInitialEmailPasswordSetup() ? [Validators.required] : []),
            gender: new FormControl('', Validators.required) // Ensure this control uses the limited options
          }, { validators: this.isInitialEmailPasswordSetup() ? passwordsMatchValidator : undefined });

          if (!this.isInitialEmailPasswordSetup()) {
            this.personalInfoForm.get('password')?.disable();
            this.personalInfoForm.get('repeatPassword')?.disable();
          }
          // ... load existing data if not initial setup ...
        }

        async onSave(): Promise<void> {
          this.personalInfoForm.markAllAsTouched();
          if (this.personalInfoForm.invalid) {
            console.log('Personal Info Form is invalid.');
            return;
          }

          const formData = this.personalInfoForm.getRawValue(); // Use getRawValue if email is disabled

          if (this.isInitialEmailPasswordSetup() && formData.email && formData.password) {
            // This is the first-time email/password setup flow
            try {
              const userCredential = await this.authService.signUpWithEmailPassword(formData.email, formData.password, formData.name || undefined);
              // Now save the rest of the profile to Firestore, including setting isRegistrationComplete = true
              // await this.userDataService.updateUserProfile(userCredential.user.uid, {
              //   displayName: formData.name,
              //   dateOfBirth: formData.dateOfBirth,
              //   gender: formData.gender, // Will be 'male' or 'female'
              //   email: formData.email, // Already set in Auth
              //   isRegistrationComplete: true,
              //   // ... other fields ...
              // });
              console.log('Initial email sign-up and profile complete for:', userCredential.user.uid);
              this.router.navigate(['/dashboard']);
            } catch (error: any) {
              // Display error from authService.mapFirebaseError(error.code)
              console.error("Error during initial email sign-up:", error);
            }
          } else {
            // This is an existing user updating their profile (or completing social sign-up)
            // Password fields should not be part of this save unless it's a "change password" flow.
            // await this.userDataService.updateUserProfile(this.authService.getCurrentUser()!.uid, {
            //   displayName: formData.name,
            //   dateOfBirth: formData.dateOfBirth,
            //   gender: formData.gender, // Will be 'male' or 'female'
            //   isRegistrationComplete: true, // Mark as complete
            //   // ... other fields ...
            // });
            console.log('Profile updated for user:', this.authService.getCurrentUser()?.uid);
            this.router.navigate(['/dashboard']);
          }
        }
        ```
    * In the HTML for `PersonalInfoPageComponent`, the `app-select-field` for gender would be bound to these limited options:
        ```html
        <!-- In personal-info-page.component.html -->
        <app-select-field
          label="Gender"
          formControlName="gender"
          [options]="genderOptions" <!-- This array now only has male/female -->
          defaultOptionText="Select your gender"
          [validators]="[Validators.required]">
        </app-select-field>
        ```
    * **On successful submission of this form:**
        * Update the user's document in Firestore.
        * Critically, set `isRegistrationComplete` to `true`.
        * Navigate to the main application area (e.g., `/dashboard`).

**C. Auth Guards Modification:**

* **`authGuard` (for protected routes like `/dashboard`, `/profile/personal-info` *if accessed for editing an existing complete profile*):**
    * After confirming Firebase `user` is not null, it should also fetch the user's document from Firestore (e.g., via `UserDataService`).
    * If `userDoc.exists && userDoc.data().isRegistrationComplete === true`, allow access.
    * If `userDoc.exists && userDoc.data().isRegistrationComplete === false`, redirect to `/profile/personal-info` to force completion.
    * If `user` is null, redirect to `/auth/login`.
* **`publicAuthGuard` (for auth routes like `/auth/login`, `/auth/sign-in`):**
    * If Firebase `user` is not null:
        * Fetch the user's document from Firestore.
        * If `userDoc.exists && userDoc.data().isRegistrationComplete === true`, redirect to `/dashboard`.
        * If `userDoc.exists && userDoc.data().isRegistrationComplete === false`, redirect to `/profile/personal-info`.
        * (If user document somehow doesn't exist yet, redirect to `/profile/personal-info` to create it).
    * If Firebase `user` is null, allow access to the auth route.

This provides a more robust flow for ensuring users complete their profile information before accessing the main parts of the application and handles the conditional display of password fields. The key is the `isRegistrationComplete` flag in your Firestore `users` collection.
</text>
